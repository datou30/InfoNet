import torch
import torch.nn.functional as F

def log_mean_exp(a):
    b = torch.max(a, dim=1, keepdim=True).values
    # Compute the mean of exponentials instead of the sum, by dividing by the number of elements in a
    return torch.log(torch.mean(torch.exp(a - b), dim=1)) + b[:, 0]

def lookup_value_grid(matrix, vector, mode):
    ## look up value from the lookup-table, table(matrix) has shape [B, d, d], vector has shape [B, N, 2]
    batchsize = matrix.shape[0]
    dim = matrix.shape[1]
    num = vector.shape[1]
    matrix = matrix.view(batchsize, 1, dim, dim)
    vector = vector.view(batchsize, num, 1, 2)
    value = (F.grid_sample(matrix, vector, mode, padding_mode='border', align_corners=True)).squeeze()
    return value   

def mutual_information(batch, matrix, num_resampling=5):

    ## compute mutual information from lookup table
    ## batch only have joint samples, marginal samples are generated by randomly shuffling y
    ## batch has shape [B, N, 2], matrix (look up table) has shape [B, D, D]
    t = lookup_value_grid(matrix, batch, "bilinear")
    if len(t.shape)==1:
        t = t.unsqueeze(0)

    log_mean_exp_et = 0
    for i in range(num_resampling):
        perm = torch.randperm(batch.shape[1])
        marginal = torch.cat((batch[:, :, 0].unsqueeze(2), batch[:, perm, 1].unsqueeze(2)), dim=2)
        et = lookup_value_grid(matrix, marginal, "bilinear")
        if len(et.shape)==1:
            et = et.unsqueeze(0)
        log_mean_exp_et += log_mean_exp(et)
        
    mi_lb = torch.mean(t, dim=1) - log_mean_exp_et/num_resampling
    if torch.isnan(- torch.mean(mi_lb) ):
        raise ValueError("Loss is NaN!")
    
    return mi_lb
